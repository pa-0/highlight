#!/usr/bin/env lua

local argparse = require "argparse"

local parser = argparse "highlight"
   :add_help(false)

parser:argument "file"
   :args "*"

parser:option "-B --batch-recursive"
   :description "convert all matching files, searches subdirs (example: -B '*.cpp')"
parser:option "-D --data-dir"
   :description "set path to data directory"
parser:option "--config-file"
   :description "set path to a lang or theme file"
parser:option "-d --outdir"
   :description "name of output directory"
parser:flag "-h"
   :description "print help and exit"
parser:option "--help"
   :description "print help or a topic description"
   :args "?"
   :choices {"syntax", "theme", "plugin", "config", "test", "lsp"}
parser:option "-i --input"
   :description "name of single input file"
parser:option "-o --output"
   :description "name of single output file"
parser:flag "-P --progress"
   :description "print progress bar in batch mode"
parser:flag "-q --quiet"
   :description "suppress progress info in batch mode"
parser:option "-S --syntax"
   :description "specify type of source code or syntax file path"
parser:option "--syntax-by-name"
   :description "specify type of source code by given name"
parser:flag "--syntax-supported"
   :description "test if the given syntax can be loaded"
parser:flag "-v --verbose"
   :description "print debug info; repeat to show more information"
   :count "*"
parser:option "--force"
   :description "generate output if input syntax is unknown"
   :args "?"
parser:option "--list-scripts"
   :description "list installed scripts with given type"
   :choices {"langs", "themes", "plugins"}
parser:option "--list-cat"
   :description "filter the scripts by the given categories (example: --list-cat='source;script')"
parser:option "--max-size"
   :description "set maximum input file size (examples: 512M, 1G; default: 256M)"
parser:option "--plug-in"
   :description "execute Lua plug-in script; repeat option to execute multiple plug-ins"
   :count "*"
parser:option "--plug-in-param"
   :description "set plug-in input parameter"
parser:flag "--print-config"
   :description "print path configuration"
parser:flag "--print-style"
   :description "print stylesheet only (see --style-outfile)"
parser:option "--skip"
   :description "ignore listed unknown file types (Example: --skip='bak;c~;h~')"
parser:flag "--stdout"
   :description "output to stdout (batch mode, --print-style)"
parser:flag "--validate-input"
   :description "test if input is text, remove Unicode BOM"
parser:flag "--version"
   :description "print version and copyright information"
parser:option "-O --out-format"
   :description "output file in given format"
   :choices {"html", "xhtml", "latex", "tex", "odt", "rtf", "ansi", "xterm256", "truecolor", "bbcode", "pango", "svg"}
parser:option "-c --style-outfile"
   :description "name of style file or print to stdout, if 'stdout' is given as file argument"
parser:option "-e --style-infile"
   :description "to be included in style-outfile (deprecated) use a plug-in file instead"
parser:flag "-f --fragment"
   :description "omit document header and footer"
parser:option "-F --reformat"
   :description "reformats and indents output in given style"
   :choices {"allman", "gnu", "google", "horstmann", "java", "kr", "linux", "lisp", "mozilla", "otbs", "pico", "vtk", "ratliff", "stroustrup", "webkit", "whitesmith"}
parser:flag "-I --include-style"
   :description "include style definition in output file"
parser:option "-J --line-length"
   :description "line length before wrapping (see -V, -W)"
parser:option "-j --line-number-length"
   :description "line number width incl. left padding (default: 5)"
parser:option "--line-range"
   :description "output only lines from number <start> to <end>"
parser:option "-k --font"
   :description "set font (specific to output format)"
parser:option "-K --font-size"
   :description "set font size (specific to output format)"
   :args "?"
parser:flag "-l --line-numbers"
   :description "print line numbers in output file"
parser:option "-m --line-number-start"
   :description "start line numbering with cnt (assumes -l)"
parser:option "-s --style"
   :description "set colour style (theme) or theme file path"
parser:option "-t --replace-tabs"
   :description "replace tabs by <num> spaces"
parser:option "-T --doc-title"
   :description "document title"
parser:option "-u --encoding"
   :description "set output encoding which matches input file encoding; omit encoding info if set to NONE"
parser:flag "-V --wrap-simple"
   :description "wrap lines after 80 (default) characters w/o indenting function parameters and statements"
parser:flag "-W --wrap"
   :description "wrap lines after 80 (default) characters"
parser:flag "--wrap-no-numbers"
   :description "omit line numbers of wrapped lines (assumes -l)"
parser:flag "-z --zeroes"
   :description "pad line numbers with 0's"
parser:flag "--isolate"
   :description "output each syntax token separately (verbose output)"
parser:flag "--keep-injections"
   :description "output plug-in injections in spite of -f"
parser:option "--kw-case"
   :description "change case of case insensitive keywords to given case"
   :choices {"upper", "lower", "capitalize"}
parser:option "--no-trailing-nl"
   :description "omit trailing newline. If mode is empty-file, omit only for empty input"
   :args "?"
   :choices {"empty-file"}
parser:flag "--no-version-info"
   :description "omit version info comment"
parser:flag "-a --anchors"
   :description "attach anchor to line numbers"
parser:option "-y --anchor-prefix"
   :description "set anchor name prefix"
parser:flag "-N --anchor-filename"
   :description "use input file name as anchor prefix"
parser:flag "-C --print-index"
:description "print index with hyperlinks to output files"
parser:flag "-n --ordered-list"
   :description "print lines as ordered list items"
parser:option "--class-name"
   :description "set CSS class name prefix; omit class name if set to NONE"
parser:flag "--inline-css"
   :description "output CSS within each tag (verbose output)"
parser:flag "--enclose-pre"
   :description "enclose fragmented output with pre tag (assumes -f)"
parser:flag "-b --babel"
   :description "disable Babel package shorthands"
parser:flag "-r --replace-quotes"
   :description "replace double quotes by \\dq{}"
parser:flag "--beamer"
   :description "adapt output for the Beamer package"
parser:flag "--pretty-symbols"
   :description "improve appearance of brackets and other symbols"
parser:flag "--page-color"
   :description "include page color attributes"
parser:option "-x --page-size"
   :description "set page size"
   :choices {"a3", "a4", "a5", "b4", "b5", "b6", "letter"}
parser:flag "--char-styles"
   :description "include character stylesheets"
parser:flag "--height"
   :description "set image height (units allowed)"
parser:flag "--width"
   :description "set image width (see --height)"
parser:option "--canvas"
   :description "set background colour padding (default: 80)"
   :args "?"
parser:option "--ls-profile"
   :description "read LSP configuration from lsp.conf"
parser:option "--ls-delay"
   :description "set server initialization delay"
parser:option "--ls-exec"
   :description "set server executable name"
parser:option "--ls-option"
   :description "set server CLI option (can be repeated)"
   :count "*"
parser:flag "--ls-hover"
   :description "execute hover requests (HTML output only)"
parser:flag "--ls-semantic"
   :description "retrieve semantic token types (requires LSP 3.16)"
parser:option "--ls-syntax"
   :description "set syntax which is understood by the server"
parser:flag "--ls-syntax-error"
   :description "retrieve syntax error information (assumes --ls-hover or --ls-semantic)"
parser:option "--ls-workspace"
   :description "set workspace directory to init. the server"
parser:option "--ls-legacy"
   :description "do not require a server capabilities response"
parser:option "--service-mode"
   :description "run in service mode, not stopping until signaled"

local p = argparse "gen-completions"
p:argument "shell"
   :choices {"bash", "zsh", "fish"}

local shell = p:parse().shell

if shell == "bash" then
   io.write(parser:get_bash_complete())
elseif shell == "zsh" then
   io.write(parser:get_zsh_complete())
else
   io.write(parser:get_fish_complete())
end
